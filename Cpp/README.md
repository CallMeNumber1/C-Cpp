# C++

#### 两个+

- 数据类型
- 面向对象设计思想

#### 常量

- const
  - C语言中是只读变量，C语言中的enum是真正的常量
  - C++中才是真正的常量，const有作用域和类型检查
- boolean的运算
  - 非0`true`
  - 0`false`

- 三目运算符
  - 当左值用时,不能含有字面量
  - 都是变量时, 返回的是变量的引用

- 引用
  - 变量的小名, 新的别名
  - 使用方式
    - 声明一个变量的引用时必须初始化
      - 特殊:引用作为参数的时候可以不用初始化(传参过程中自动完成)
    - 别名的类型和原来类型相同
  - 大部分情况下引用可以代替指针
    - 特殊:作为传出参数时不能代替指针
    - 因为局部变量使用后销毁,因此取别名也没有用

```c++
int a = 5;
int &b = a;
使用举例:swap(int &a, int &b)
```

#### 函数默认值

- 从右往左
- 传参时参数的数量要大于默认参数的个数
- 当函数声明和实现分开写时
  - 声明的时候写上,定义的时候不用写也不能写
- 占位参数
  - 可以实现c向c++的兼容

```c++
void g(int = 0, int = 0, int = 0) {
    cout << "hello g" << endl;
}
int main() {
    g();
    g(1, 2, 3);
    return 0;
}
```

#### 函数重载

- 同一作用域
- 函数名相同
- 参数列表不同
  - 参数类型,个数,顺序
- 函数指针和函数重载一起用
  - 不仅参数列表要相同
  - 返回类型也要相同
- 编译器调用准则
  - 所有重载函数都作为备选对象
  - 编译器尝试寻找匹配函数
    - 精确匹配

#### new/delete

- 在堆空间申请单个变量/一组连续的空间

```cpp
//type可以是基本数据类型/类
type *name = new type
delete name
//给单个变量初始化
type *name = new type(value)
delete name
//申请一堆连续的空间
type *name = new type[length]
delete[] name
```

#### 类

- 先有对象,通过对象抽象出类
- 属性: 描述类的属性的变量
- 方法: 表示类的行为特性
- 作用域: 在类的同一个作用域中没有访问权限这个概念

#### 构造函数

- 默认提供无参构造函数

#### 构造函数的初始化列表

- 背景
  - 类属性可以用const修饰,因此普通初始化方法无法使用
  - 在构造函数中给private const变量赋初值不允许
  - const类型属性必须用初始化列表去初始化
- 使用初始化列表的情况
  - const成员属性
  - 类属性
    - 类中有带参数构造函数时
- 注意事项
  - 初始化列表的初始化顺序与成员属性的声明顺序相同
  - 初始化顺序与实际书写的位置无关
  - 初始化列表优先于函数体执行
- 当执行到构造函数的函数体时, 此对象已经生成了

```cpp
class Test {
    private:
        const int i;
        int a;
        Value v1;
    public:
        Test(int v1, int v2);
        int getI() {
            return i;
        }
};
Test::Test(int v1, int v2) : i(v1), a(v2), v1(1) {
    cout << "i = " << i << endl;
    cout << "a = " << a << endl;
}
```

#### 析构函数

- 无参数, 无返回值
  - 说明不可被重载
  - 一个类中只有一个析构函数
- 堆上的对象
  - new调用构造函数, delete调用析构函数

#### 构造函数构造顺序

- 单个对象
- 全局对象
  - C++标准没有定义全局对象的构造顺序,所以不同编译器结果不同
  - 没有固定顺序,没有统一标准
  - 因此尽量不要使用全局对象
- 对象构造顺序:先父母,再朋友,后自己
  - 析构函数顺序与构造相反

#### 拷贝构造函数

- 编译器默认提供一个,简单的值赋值
  - 浅拷贝, 拷贝后物理状态相同
  - 不涉及指针和内存相关操作时, 浅拷贝即可
- 用已经存在的一个对象初始化一个新的对象
- 手动实现时一定要写`深拷贝`
  - 浅拷贝会导致内存重复释放等问题
  - 深拷贝, 逻辑状态相同

#### 静态成员变量

- 属于整个类, 所有对象共享, 生命周期整个程序
- 可通过类名直接访问共有静态成员变量
- 访问级别

#### 静态成员方法

- 即类方法, 没有this指针
- 静态成员方法不能直接访问成员变量

#### 静态/成员方法比较

|              | 静态 | 普通 |
| :----------: | ---- | ---- |
| 所有对象共享 | √    | √    |
|  this'指针   | ×    | √    |
| 访问普通成员 | ×    | √    |
| 访问静态成员 | √    | √    |
| 通过类来调用 | √    | √    |
| 通过对象访问 | √    | √    |

- 对象在内存中属性是自己的, 方法是大家的

- 每个成员方法里都有一个this指针, 即对象地址

- 而静态成员函数没有this指针

- this:当前对象的指针 
  - 返回当前对象的某个值, 用的当前对象的某个值

#### const对象与方法

- const对象的性质
  - 属性都是只读的, 在编译期只读对象成员属性不能被改变
  - 只能调用const方法.`Type funcName() const {}`
- const方法与普通方法构成重载关系
- const成员方法内部只能调用const方法
- const成员方法中不能改变普通成员属性的值
- C++程序中直接用const变量中就是一个真正的常量, 而在类中作为属性时, 是只读的.



 :date:2018.01.08 周二

#### struct与class区别

- 默认访问权限, struct为public, class为private

#### 返回值优化

- 临时对象（也是匿名对象）
  - 生命周期只有当前行

- 当无参构造函数调用有参构造函数时会出现这种情况

```cpp
Test t[3] = {Test(), Test(100), Test(10)};
// 设计到临时对象，以及拷贝构造函数
Test t = Test(100)
// 先产生临时对象，再调用拷贝构造函数
// C++在编译时默认进行返回值优化,相当于t = 10
Test func() {
	Test t(100);
    return t;
}
Test t1 = func();
// 会调用两次拷贝构造
// c++返回值优化后,不调用拷贝构造,相当于 t1 = 100
```

- 关闭返回值优化

  `g++ test.cpp -fno-elide-constructors`

#### 组合

构造顺序：先父亲，后朋友，再自己（这句话是递归使用的）

- 其他类的对象当做当前类的成员
- 其他类对象的生命周期与当前类的对象相同
- 成员对象在用法上与普通成员相同

#### 继承

类与类之间的关系，单向的

代码复用

- 用法：`class A: 继承方式`

- 特点
  - 子类继承父类的所有属性和方法
  - 子类是一种特殊父类，子类对象可以当父类对象用
  - 子类可以添加自己的属性和方法，可以重写父类的方法

:date:2018.01.10 周四

- 继承方式
  - 工程上常用public

- 构造函数
  - 先构造父类，再构造子类
  - 默认调用方式：要求父类构造函数必须是无参或带默认参数的
    - 详见昨天演示代码
- **构造顺序**
  - 子类对象构造时需要先初始化父类属性，需要调用父类构造函数（自动，手动）
  - 构造函数执行顺序为`先父亲，后朋友，再自己`
  - 父类构造函数显式调用时必须在子类构造函数初始化列表中
  - 子类对象销毁时同样需要调用父类析构函数（只是自动调用）
  - 先构造的后析构
- **同名冲突**
  - 当子类定义了与父类同名属性时，优先使用子类的属性，编译器自动将父类的隐藏掉（实际仍存在），可使用**作用域分辨符**来使用父类的同名属性`b.A::i`
  - 子类和父类中同名方法不构成重载关系，是**重写**
    - 因为两个类位于不同作用域，而重载要求同一作用域
  - 使用作用域分辨符访问同名成员属性和方法

- 父子兼容
  - 子类是个特殊的父类
  - 子类对象可以初始化父类对象
  - 父类指针可以指向子类
  - 父类对象的引用可以引用子类对象

```cpp
B b;
A *p1 = &b; A &p2 = b;
```

当不使用虚函数时，编译器统一解释为父类的版本，这样不会出问题。

#### 对象模型

- 成员属性和成员方法分开存储
- sizeof为属性的大小
- class是特殊的struct，编译期看访问权限，运行时退化成了struct
- 成员属性是依次排列的，成员属性之间可能存在内存空隙
- 可以通过内存地址直接访问（说明访问权限只是告诉编译器，运行时仍然可以通过地址访问）

class的C语言实现

#### 多继承

**继承是简单的堆叠**

```cpp
例如C继承A，B，C的内存排布为：依次先A后B再C
特别的，当A和B中都有虚函数时，C中首部会分别增加A和B的虚函数指针（指针8字节）
```

多继承+父子兼容时

- 指向子类的父类指针会指向不同地方，父子兼容直接退化成父类

![2019-01-10 20-58-47屏幕截图](/home/chongh/图片/2019-01-10 20-58-47屏幕截图.png)

多继承问题

- 不知道调哪个函数
  - 使用作用域分辨符
- 一个对象可能有多个地址
- 数据冗余
  - 首先要在最底层子类构造函数中调用最顶层父类的构造函数

解决方案：虚继承，但工程上不好管理

#### 多态

不同对象产生不同行为

根据实际对象取判断调用的函数

virtual关键字

- 声明多态
- 被virtual修饰的函数具有多态性，叫虚函数
  - 相关概念：纯虚函数，抽象类，接口
- 父类中某函数声明后，子类中默认virtual

`注意：virtual不能修饰类方法（static）`

多态意义

- 在程序中表现出动态特性
- 在子类三种重写父类同名函数必须声明成虚函数（父类中声明），否则没有意义

多态实现原理

当有virtual时，编译器改变了对象的内存排布

1. 在类声明虚函数时，编译器会自动生成一个**虚函数表**
2. 虚函数是一个存储成员函数地址的数据结构
3. 虚函数表由编译器自动生成和维护
4. 被virtual修饰的虚函数会被放入虚函数表中
5. 存在虚函数时，每个对象会有一个指向虚函数表的指针并且此指针在对象的头部

- 在多态时，编译器会对类做一些改变，在头部增加虚函数表指针，对象内有个指向虚函数表的指针`vptr`，其中存的是要表现多态性函数的地址。占8个字节

静态联编：程序在编译期间就知道调用哪个函数（函数重载）

动态联编：程序在运行期间才知道调用哪个函数（函数重写）

#### 纯虚函数

- 纯虚函数没有函数体，同时在定义的时候，其函数名后面要加上“=0”

应用场景：定义接口

#### 抽象类

- 包含纯虚函数的类成为抽象类
- 对于抽象类来说，它无法实例化对象，而对于抽象类的子类来说，只有把抽象类中的纯虚函数全部实现之后，那么这个子类才可以实例化对象

#### 接口

- 没有任何成员属性
- 所有方法都是pubic的纯虚函数

#### 单继承+多接口

1.16课堂任务

- c语言实现继承
- 实现多态
  - 过程: 比如p->say()是一个虚函数，1.插指针，确定2.在构造函数中关联相关指针

#### C++中的强制类型转换

**reinterpret_cast<>**（两个不同类型进行强制类型转换时）

- dynamic_cast

和继承、虚函数相关的强制类型转换用`dynamic_cast`

```cpp
BaseA *p1
BaseB *pb = dynamic_cast<BaseB*>(p1)
```

泛型编程：包括函数模板和类模板

## 函数模板

 例如，编写一个交换函数时，可以使用`宏实现`和`函数实现`

	宏实现是通用的但安全性不足
	
	函数实现安全，但同样的功能要重载，有大量重复工作

因此引入函数模板的概念。

- 概念：一种泛型编程方式，不考虑数据类型

`template<typename T>`

template: 开始模板编程

typename: T是类型名

- 会进行两次检查：

  数据类型检查

- 意义
  - 函数模板能根据实参类型进行参数类型推导
  - 支持显示指定参数类型
  - 是c++中代码复用的一种形式

```cpp
例如：
template <typename T>
void my_sort(T *a, int len) {
    for (int i = 0; i < len; i++) {
        for (int j = i; j < len; j++) {
            if (a[i] > a[j]) {
                my_swap1(a[i], a[j]);
            }
        } 
    }
    return ;
}
string s[5] = {"c", "python", "java", "cpp", "c#"}；
my_sort(s, 5); 			// 自动类型推导
my_sort<string>(s, 5); 	// 显式指定类型
```

- 使用注意事项
  - 函数模板本身不支持隐式类型转换
  - 自动推导类型时，必须严格遵守类型匹配，而且不会进行隐式类型转换
  - 显式指定时，能够进行隐式类型转换
  - 多个类型参数时，返回值类型无法自动推导
  - 可以从左至右部分指定参数类型

```c
多类型参数部分指定参数例子：
template <typename T1, typename T2, typename T3>
T1 add(T2 a, T3 b) {
    return static_cast<T1>(a + b);
}
int r1 = add<int>(0.5, 0.3);				// 0
int r2 = add<int, float>(0.3, 0.6); 		// 0
int r3 = add<int, float, float>(0.5, 0.5);	// 1

```

另外：模板函数和普通函数能构成重载关系

#### 编译器对函数调用顺序

普通函数、模板函数、变参函数重载时：
**优先调用普通函数，再调用模板函数，都没有时才调用变参函数**

```cpp
void add(int a, int b) {
    cout << "void add(int a, int b)" << endl;
    cout << a + b << endl;
    return ;
}
template <typename T>
void add(T a, T b) {
    cout << "void add(T a, T b)" << endl;
    cout << a + b << endl;
    return ;
}
void add(...) {
    cout << "void add(...)" << endl;
    return ;
}
add(1, 3) 		// 调用普通函数
add(2.4,3.6) 	// 调用模板函数
add(3) 			// 调用变参函数
add<>(1, 3) 	// 此时只会从模板函数中选择
```

## 类模板

泛型编程

适合写数据结构

不同数据类型，对数据进行的操作

```cpp
// 类模板使用
Test<int> t;
```

同样两次编译：先对代码进行编译，加进去类型后再进行一次编译

#### 类模板实现

1. 当在类外实现成员函数时

```cpp
template <typename T>
class_name<T>::func() {
}
```

2. 类模板声明和实现要在同一个头文件中

#### 多参数类模板

**特化**（类模板的另一种特殊形式）

部分特化（偏特化）、完全特化

类模板

- 可以有多个类型参数
- 特化和类模板分开实现
- 特化的类模板，使用方法一样，必须显示指定参数类型
- 有多个特化模板，根据不同参数类型去选择不同特化

另外：

- 函数模板也支持特化，但只支持完全特化

#### 完全特化与部分特化

完全特化：完全指定出类型参数

部分特化：除了完全的都是部分的。用特定规则去约束类型参数

	比如原来要传两个参数，现在只想传一个参数，或一个指定类型一个类型参数

```cpp
template <typename T1, typename T2>
class Test {}
// 完全特化
template <>
class Test(int, int) {}
// 部分特化
template <typename T>
class Test<T, T> {}
```

## 关于泛型编程的总结

模板函数和模板类两种

模板函数

```cpp
// 1.用法
// 2.多参数类型（模板和模板之间，模板和普通函数之间）
// 3.重载
```

模板类

```cpp
// 1.用法
template<typename T>
class Test {} 		// 其中T可以在类内任何位置使用
// 2.多参数类型
// 3.特化
```

#### 模板参数可以是数值类型参数

使用注意事项

1. 数值类型参数不能用变量、浮点类型、类类型

   凡是不确定的类型都不可以，因为浮点在编译期间是不确定的

2. 

随堂问题

- 怎么判断一个变量是普通变量还是指针变量

## 异常处理

bug和异常的区别

- bug 不可预期的 由思维不严谨造成 

堆空间申请未释放、野指针、排序0长度的组

- 异常 可预期的分支流程

a/b被除数为0、数组访问越界、打开不存在的文件

C语言处理异常时，正常的代码放到if里，异常情况放到else里

C++异常处理

```cpp
try {
    // 执行正确代码
} catch () {
    // 异常处理
}
```

catch()中捕获的可以是任意类型，但匹配时是**严格匹配**，不会进行类型转换

`catch(...)`只能放到最后，当能想到的异常类型都写完时，最后写这个。

使用注意事项：

1. try后可以跟多个catch

2. catch块中可以定义具体异常类型
3. 不同异常类型用不同catch去处理
4. catch(...)表示可以处理任意类型异常，并且只能放到最后
5. 任意一种类型的异常只能被捕获一次

匹配规则

1. 自上而下严格匹配异常类型
2. 匹配时不进行类型转换

关于throw的过程

```cpp
f1调用f2，f2再调用f3
1. 当f3抛出异常时，f3先看能否处理，若不能则往上返回(是原封不动往上抛的)
2. f2看能否处理，若不能继续往上返回
3. f1如果是主函数，仍不能处理，则程序异常结束
```

try-catch的嵌套

catch中是可以直接throw的

自定义类型异常

1. 异常可以是自定义类型的

2. 同样遵循严格匹配

3. 父子兼容依然适用，因此一般原则

   匹配子类异常的放在上面，匹配父类异常的放在下面，匹配其他异常的放到最后

C++标准库的异常类

例如out_of_range类的使用

```cpp

```

## 操作符重载

友元

1. 在类中某个函数前用friend修饰

2. 友元函数不是类的一部分

3. 友元函数不受类中访问权限限制

   友元函数破坏类的封装性，因此一般不使用

友元是一种单向的关系，不会传递

	即A是B的友元，B是C的友元，但A不是C的友元

声明友元类：`friend class A`

	例如在B中声明，则A是B的友元类，A可以访问B中的任何属性，但B不能访问A的

为什么要操作符重载

1. 全局函数要求类属性是公有的 ×

2. 类的友元函数实现会影响类的封装性 ×

因此引入操作符重载，本质：一种特殊的函数

1. 通过函数重载去扩展系统操作符的功能
2. 操作符重载是以函数方式进行的

重载运算符可以被定义为普通的非成员函数或者定义为类成员函数

	如果定义为非成员函数(全局函数），那么每次操作需要两个参数
	
	如果定义为类成员函数，则一个参数即可。（this可作为一个参数）

1. 有些运算符只能重载成成员函数
2. 操作符重载不能改变原来操作符的运算优先级
3. 不能改变操作数的个数
4. 不能改变原运算符的原生语义

另外，重载后调用`c1.operator+(c2)`相当于`c1+c2`

#### 重载赋值运算符=

赋值运算符只能重载为成员函数，**当需要深拷贝时（设计到内存相关操作）才需要重载，否则使用系统默认提供的浅拷贝即可**

实现时

	防止自赋值
	
	实现深拷贝
	
	返回左值引用

当重载成成员函数时

```cpp
// 当重载运算符作为成员函数时，传入的参数要为const类的引用，或者一个实在的对象(const Test &t 或者 Test t)
class Test {
public:
	Test operator+(const Test &t) {}    
    Test& operator=(const Test &t) { 		
    }
}
```

#### 重载下标运算符[]

[]:数组元素访问、指针运算

```cpp
a[n] = *(a + n) = *(n + a) = n[a]
```

1. 只重载成员函数
2. 重载函数只能有一个参数
3. 参数类型可以不一样

#### 重载运算符（）

小故事：实现一个fib，调用几次，值就为第几次的值

定义函数实现的时候要用static变量，不安全，因此可封装到对象里，用对象代替

1. 只能重载成员函数
2. ？？？可定义多个不同参数的多个重载函数

意义：

1. 用对象去代替函数
2. 当前对象具备了函数的行为

## 智能指针

#### 内存泄露：

	堆上申请的空间没有释放，在局部变量消失后，访问不到这块内存

#### 要求

1.主动归还堆空间

	析构函数

2.每次只能有一个指针指向它（防止delete两次）

	指针之间赋值需重载：不自赋值、先回收当前指向的空间，p1赋值，p2置空，最后返回左值引用

	另一种要考虑拷贝构造 这时p1=p2, p2=NULL即可

3.兼容原来指针运算 不能加减 比较

#### 声明一个类后自己就不再支持，需要重载

#### 几条特性

1. 能智能回收堆空间
2. 一片内存空间只能有一个指针指向（避免多次释放）
3. 杜绝指针运算（没有重载那些符号即可）

#### -> *重载注意事项

1. 不能有参数，即不能重载

2. 只能是成员函数

3. 一个类中只能定义一个这样的函数

智能指针只能用于堆空间的，

是用对象模拟原生指针的行为 p替代Test *p

#### 标准库中的智能指针

#### 逻辑运算符与重载

重载本质上是**函数调用**

重载逻辑运算符无法实现最短路原则，不推荐。

表象：func(t1) || func(t2) 

实质：operator||(func(t1), func(t2)) 不满足最短路，不推荐

不满足原生语义的都不推荐重载

有些不推荐重载的，非要重载，就重载成全局函数

#### 问题

为什么成语函数重载运算符时需要传const引用？

	好处1. const引用可以用const和非const初始化

 	2. 引用本身不占空间，因此少一次拷贝构造

	而非const只能用非const初始化

	临时对象的属性是const的

引用能做左值和右值，关于引用的知识



船长推荐书目：C++对象模型